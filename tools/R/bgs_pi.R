# Date created: 04/03/2024
# Last modified: 28/03/2024
# Author: Gustavo V. Barroso
# This script does the heavy-lifting of the pipeline to simulate genomic
# landscapes. Here we compute B-values for sampled sites,
# interpolate them and multiply by local mu to generate predictions of
# pairwise diversity along the chromosome that was simulated by bgs_maps.R

#!/usr/bin/env Rscript
args=commandArgs(trailingOnly=T)

# space-separated positional arguments in Rscript --vanilla bgs_pi.R x y z
num_iter <- as.numeric(args[1]) # for updating B-vals due to interference sel.
jump_length <- as.numeric(args[2]) # sampling distance for interpolating B-vals
downsample <- as.numeric(args[3]) # no. of neutral pos sampled in-between exons
# NOTE: downsample==1 is a special case where no thinning is performed

pdf(NULL) # to suppress creation of Rplots.pdf

suppressMessages({
  library(R.utils)
  library(tidyverse)
  library(data.table)
  library(pracma) # for cubicspline()
  library(cowplot)
  library(scales)
  library(RColorBrewer)
})

print(Sys.time())
cat(paste("Computing B-values by sampling every", jump_length, "site(s),\n"))
cat(paste("with between-exon downsample =", downsample,"\n\n"))
    
lookup_tbl <- fread("../../lookup_tbl.csv.gz") # generated by setup_models.Rmd

N <- unique(lookup_tbl$N) # should be of length 1
u <- unique(lookup_tbl$u) # should be of length 1
bin_size <- 1e+3 # "basal" scale, should be the same as in bgs_maps.R

dt_r <- data.table(unique(lookup_tbl[,3]))
dt_s <- data.table(unique(lookup_tbl[,4]))

setkey(dt_r, lookup_r)
setkey(dt_s, lookup_s)

# loads tables generated by bgs_maps.R
mmap <- fread("mmap.csv")
rmap <- fread("rmap.csv")
smap <- fread("smap.csv")

dt_neutral <- filter(smap[,2:4], s==0)
dt_exons <- filter(smap[,2:4], s<0)

setkey(mmap, start, end)
setkey(rmap, start, end)
setkey(smap, start, end)
setkey(dt_neutral, start, end)
setkey(dt_exons, start, end)
setkey(lookup_tbl, lookup_r, lookup_s)

exon_lengths <- unique((dt_exons$end - dt_exons$start)) # should be of length 1
L <- mmap$end[nrow(mmap)] # seq length, same for all maps

# finding mu for each sampled position
neut_pos <- unlist(apply(dt_neutral, 1, 
                function(x) seq(from=x[1], to=x[2], by=jump_length))) + 1
samp_pos <- sort(c(neut_pos, dt_exons$start + exon_lengths / 2)) # sampled sites

focal_mu <- unlist(lapply(samp_pos, function(pos) mmap[J(pos), roll=T]$u))

pos_dt <- suppressMessages(setDT(bind_cols(samp_pos, focal_mu)))
names(pos_dt) <- c("position", "focal_mu")
setkey(pos_dt, position)

# thinning sampled neutral sites clustered away from exons to decrease runtime
# heuristic: downsample to a maximum no. of sampled neutral sites between exons
pos_dt$neutral <- pos_dt$position %in% neut_pos
runs <- rle(pos_dt$neutral)
runs <- cbind.data.frame(runs$lengths, cumsum(runs$lengths), runs$values)  
names(runs) <- c("run_length", "end_idx", "neutral")
short_runs <- filter(runs, run_length <= downsample)
long_runs <- filter(runs, run_length > downsample)

short_runs$start_idx <- short_runs$end_idx - short_runs$run_length + 1
short_runs <- dplyr::select(short_runs, c(start_idx, end_idx))
short_pos <- unique(unlist(apply(short_runs, 1, function(x) seq(x[1], x[2],1))))

long_runs$start_idx <- long_runs$end_idx - long_runs$run_length + 1
long_runs <- dplyr::select(long_runs, c(start_idx, end_idx))

downsample_pts <- function(y) {
  if(downsample==1) { return(seq(min(y), max(y), downsample)) }
  else {
    return(as.integer(seq(min(y),max(y), (max(y) - min(y)) %/% (downsample-1))))
  }
}

thinned_neut <- unlist(apply(long_runs, 1, downsample_pts))
thinned_pos <- sort(unique(c(thinned_neut, short_pos)))

pos_dt <- pos_dt[thinned_pos,] # thinning based on downsample
pos_dt$idx <- 1:nrow(pos_dt) # indexing
samp_pos <- pos_dt$position # updates after thinning

B_values <- rep(1, length(samp_pos)) # init 
tbl <- as.data.frame(matrix(ncol=num_iter, nrow=length(B_values))) # for viz

for(i in 1:num_iter) {
  # approximates cumulative rec by looking at r at sampled sites only
  focal_r <- unlist(lapply(samp_pos, function(pos) rmap[J(pos), roll=T]$r)) 
  focal_r <- focal_r * B_values
  cum_rec <- numeric(length=length(samp_pos))
  cum_rec[1] <- focal_r[1]
  
  for(j in 2:length(samp_pos)) {
    cum_rec[j] <- cum_rec[j-1] + (samp_pos[j] - samp_pos[j-1]) * focal_r[j]
  }
  pos_dt$cumrec <- cum_rec
  
  # pre-computes "effective" rec. dist. between sampled sites and exons
  cr_exons <- pos_dt[position %in% (dt_exons$start + exon_lengths / 2),]
  prd <- as.data.frame(2 * N * abs(outer(pos_dt$cumrec, cr_exons$cumrec, "-")))
  names(prd) <- 1:ncol(prd)
  
  erd <- prd # "effective" rec. distance is inversely proportional to alpha
  for(j in 1:ncol(erd)) { erd[,j] <- erd[,j] / abs(2 * N * dt_exons$s[j]) }
  relevant_exons <- apply(erd, 2, function(x) x < 10 * N * 1e-3)
  # identifying relevant exons (w.r.t. linked selection) for each sampled site
  exons_per_samp_site <- apply(relevant_exons, 1, function(x) which(x))
  
  getB <- function(focal_exon, focal_samp) { # arguments are site indices
    total_r <- prd[focal_samp, focal_exon] / (2 * N) 
    if(total_r > 1e-2) { return(1) } # not in lookup_tbl, too high anyway
    else {
      exon_pos <- dt_exons$start[focal_exon] + exon_lengths / 2 # midpoint pos
      idx <- pos_dt[.(exon_pos)]$idx # index within pos_dt / samp_pos
      dt_exons[focal_exon,]$s <- dt_exons[focal_exon,]$s * B_values[idx]
      focal_s <- dt_exons[focal_exon,]$s 
      
      # lookup_tbl grid is fine-grained enough, we don't need interpolation
      closest_r <- dt_r[dt_r[.(total_r), roll="nearest", which=T]]
      closest_s <- dt_s[dt_s[.(focal_s), roll="nearest", which=T]]
      
      # correction for interference on u is applied by scaling exon lengths
      hr <- lookup_tbl[.(closest_r, closest_s)]$Hr # lookup_tbl has single u val
      return((hr / (2 * N * u)) ^ (exon_lengths * B_values[idx]))
    }
  }
  
  # TODO flip and loop over exons, subset lookup_tbl by closest_s to make it faster
  tmp <- B_values # temporary copy to avoid mixing old and new B-vals in getB()
  cat(paste("Computing B's...(iteration ", i, " of ", num_iter, ")\n", sep=""))
  pb <- txtProgressBar(min=1, max=length(exons_per_samp_site), style=3)
  for(k in 1:length(exons_per_samp_site)) {
    setTxtProgressBar(pb, k)
    if(length(exons_per_samp_site[[k]]) > 0) {
      B <- unlist(lapply(exons_per_samp_site[[k]], getB, focal_samp=k))
      tmp[k] <- cumprod(B)[length(B)]
    }
    else {
      tmp[k] <- 1 
    }
  }
  close(pb)
  
  B_values <- tmp
  tbl[,i] <- B_values
}

cat("Performing cubic splines interpolation...")
B_map <- cubicspline(samp_pos, B_values, 1:L)
cat("done.\nNow preparing output files.\n")
ones <- rep(1, L)

# uses closed intervals to map values from for mmap (+1 start coordinates)
pi0s <- invisible(apply(mmap, 1, function(x)
  ones[(as.numeric(x[2]) + 1):as.numeric(x[3])] *
    as.numeric(x[4]) * 2 * N))
pis <- invisible(apply(mmap, 1, function(x)
  B_map[(as.numeric(x[2]) + 1):as.numeric(x[3])] *
    as.numeric(x[4]) * 2 * N))

pi0s <- unlist(pi0s)
pis <- unlist(pis)
hrmap <- suppressMessages(setDT(bind_cols(1:L, pis, pi0s, B_map)))
names(hrmap) <- c("Pos", "Hr", "pi0", "B")
fwrite(hrmap, "hrmap.csv.gz", compress="gzip") 

# binning in preparation to execute bgs_lm.R and bgs_viz.R
hrmap$bin <- ((hrmap$Pos - 1) %/% bin_size)
hrmap_1kb <- hrmap %>% group_by(bin) %>%
  summarize(avg_pi=mean(Hr), avg_pi0=mean(pi0), avg_B=mean(B))
hrmap_1kb$bin_10kb <- hrmap_1kb$bin %/% 10
hrmap_1kb$bin_100kb <- hrmap_1kb$bin %/% 100
hrmap_10kb <- hrmap_1kb %>% group_by(bin_10kb) %>% 
  summarise_at(c("avg_pi", "avg_pi0", "avg_B"), mean)
hrmap_100kb <- hrmap_1kb %>% group_by(bin_100kb) %>% 
  summarise_at(c("avg_pi", "avg_pi0", "avg_B"), mean)

# loads results of bgs_maps.R
maps_1kb <- fread("maps_1kb.csv")
maps_10kb <- fread("maps_10kb.csv")
maps_100kb <- fread("maps_100kb.csv")

# appends hrmaps by their trimming tails
maps_1kb$avg_pi <- hrmap_1kb$avg_pi[1:nrow(maps_1kb)] 
maps_10kb$avg_pi <- hrmap_10kb$avg_pi[1:nrow(maps_10kb)]
maps_100kb$avg_pi <- hrmap_100kb$avg_pi[1:nrow(maps_100kb)] 

maps_1kb$avg_B <- hrmap_1kb$avg_B[1:nrow(maps_1kb)] 
maps_10kb$avg_B <- hrmap_10kb$avg_B[1:nrow(maps_10kb)]
maps_100kb$avg_B <- hrmap_100kb$avg_B[1:nrow(maps_100kb)] 

# over-writing
fwrite(maps_1kb, "maps_1kb.csv")
fwrite(maps_10kb, "maps_10kb.csv")
fwrite(maps_100kb, "maps_100kb.csv")

# visualizing the iterative correction for interference selection
names(tbl) <- as.character(1:num_iter)
tbl$pos <- as.integer(samp_pos)
fwrite(tbl, "interf_iter.csv")
  
m_tbl <- pivot_longer(tbl, cols=as.character(1:num_iter), names_to="Iteration")
m_tbl$Iteration <- as.numeric(m_tbl$Iteration)

nb_cols <- ncol(tbl) - 1
mycolors <- colorRampPalette(brewer.pal(8, "YlOrRd"))(nb_cols)
pa <- ggplot(data=filter(m_tbl, pos>1e+6, pos<2e+6),
             aes(x=pos, y=value, color=as.factor(Iteration))) + 
  geom_point(aes(alpha=0.5)) + theme_bw() + geom_line() + 
  scale_fill_manual(values=mycolors) +
  scale_x_continuous(breaks=pretty_breaks()) +
  scale_y_log10(breaks=pretty_breaks()) + guides(alpha="none") + 
  labs(title="Iterative correction for interference", x="Pos", y="B-value") +
  theme(axis.title=element_text(size=16), 
        axis.text=element_text(size=12), 
        axis.text.x=element_text(size=12),
        legend.text=element_text(size=16),
        legend.title=element_text(size=16),
        legend.position="bottom")

save_plot("Interf_B-vals.png", pa, base_height=8, base_width=16)

avg_bvals <- as.data.frame(apply(tbl[,1:(ncol(tbl)-1)], 2, mean))
sd_bvals <- as.data.frame(apply(tbl[,1:(ncol(tbl)-1)], 2, sd))
cv_bvals <- sd_bvals / avg_bvals
names(cv_bvals) <- "cv_bvals"
cv_bvals$iter <- 1:nrow(cv_bvals)

pb <- ggplot(data=cv_bvals, aes(x=iter, y=cv_bvals)) + 
  geom_point() + theme_bw() + geom_line() + 
  scale_x_continuous(breaks=pretty_breaks()) +
  scale_y_continuous(breaks=pretty_breaks()) + 
  labs(title="Iterative correction for interference", x="Iter", y="CV(B)")+
  theme(axis.title=element_text(size=16), 
        axis.text=element_text(size=12), 
        axis.text.x=element_text(size=12),
        legend.text=element_text(size=16),
        legend.title=element_text(size=16),
        legend.position="bottom")

save_plot("Interf_CV_Bvals.png", pb, base_height=8, base_width=16)

diffs <- as.data.frame(matrix(nrow=nrow(tbl), ncol=ncol(tbl)-2))
for(i in 2:(ncol(tbl)-1)) {
  diffs[,i-1] <- tbl[,..i] - tbl[,..i-1]
}
names(diffs) <- 1:ncol(diffs)

mean_diffs <- as.data.frame(apply(diffs, 2, mean))
names(mean_diffs) <- "diff"
mean_diffs$iter <- 1:nrow(mean_diffs)

pc <- ggplot(data=mean_diffs, aes(x=iter, y=diff)) + 
  geom_point() + theme_bw() + geom_line() + 
  scale_x_continuous(breaks=pretty_breaks()) +
  scale_y_continuous(breaks=pretty_breaks()) + 
  labs(title="Iterative correction for interference", x="Iter", y="Mean(Diff)")+
  theme(axis.title=element_text(size=16), 
        axis.text=element_text(size=12), 
        axis.text.x=element_text(size=12),
        legend.text=element_text(size=16),
        legend.title=element_text(size=16),
        legend.position="bottom")

save_plot("Interf_mean_diffs.png", pc, base_height=8, base_width=12)

sd_diffs <- as.data.frame(apply(diffs, 2, sd))
names(sd_diffs) <- "diff"
sd_diffs$iter <- 1:nrow(sd_diffs)

pd <- ggplot(data=sd_diffs, aes(x=iter, y=diff)) + 
  geom_point() + theme_bw() + geom_line() + 
  scale_fill_manual(values=mycolors) +
  scale_x_continuous(breaks=pretty_breaks()) +
  scale_y_continuous(breaks=pretty_breaks()) + 
  labs(title="Iterative correction for interference", x="Iter", y="SD(Diff)") +
  theme(axis.title=element_text(size=16), 
        axis.text=element_text(size=12), 
        axis.text.x=element_text(size=12),
        legend.text=element_text(size=16),
        legend.title=element_text(size=16),
        legend.position="bottom")

save_plot("Interf_sd_diffs.png", pd, base_height=8, base_width=12)

# visualizing the validity of threshold for spotting "relevant" exons
rex <- apply(prd, 2, function(x) x < 4 * N * 1e-2) 
ex400 <- apply(rex, 1, function(x) which(x)) # flagging all exons w/ rho < 400

# B's at left-most site in chr, counting exons < 400 rho
Bl400 <- unlist(lapply(ex400[[1]], getB, focal_samp=1)) # NOTE ex400[,1] Linux
# B's at site 1/4 in chr, counting exons < 400 rho
Bq400 <- unlist(lapply(ex400[[length(samp_pos)/4]], getB, # NOTE ex400[,*] Linux
                       focal_samp=length(samp_pos) %/% 4))
# B's at site in middle of chr, counting exons < 400 rho
Bm400 <- unlist(lapply(ex400[[length(samp_pos)/2]], getB, # NOTE ex400[,*] Linux
                       focal_samp=length(samp_pos) %/% 2))

# B's at left-most site in chr, counting exons flagged as relevant in erd matrix
Blr <- unlist(lapply(exons_per_samp_site[[1]], getB, focal_samp=1))
# B's at site 1/4 in chr, counting exons flagged as relevant in erd matrix
Bqr <- unlist(lapply(exons_per_samp_site[[length(samp_pos)/4]], getB,
                     focal_samp=length(samp_pos) %/% 4))
# B's at site in middle of chr, counting exons flagged as relevant in erd matrix
Bmr <- unlist(lapply(exons_per_samp_site[[length(samp_pos)/2]], getB,
                     focal_samp=length(samp_pos) %/% 2))


if(any(is.null(Bl400), is.null(Bq400), is.null(Bm400),
       is.null(Blr), is.null(Bqr), is.null(Bmr))) {
  stop(paste("Won't plot B-vals because some sites are not influenced by BGS.",
             "Quitting, but other output files are ready."))
}


xl <- cbind.data.frame(as.numeric(prd[1, as.numeric(names(Bl400))]), Bl400)
xq <- cbind.data.frame(as.numeric(prd[1, as.numeric(names(Bq400))]), Bq400)
xm <- cbind.data.frame(as.numeric(prd[1, as.numeric(names(Bm400))]), Bm400)

names(xl) <- c("rec", "B")
names(xq) <- c("rec", "B")
names(xm) <- c("rec", "B")

xl$CummBval <- cumprod(xl$B)
xq$CummBval <- cumprod(xq$B)
xm$CummBval <- cumprod(xm$B)

xl$relevant <- xl$B %in% Blr
xq$relevant <- xq$B %in% Bqr
xm$relevant <- xm$B %in% Bmr

pl <- ggplot(data=xl, aes(x=rec, y=B, color=relevant)) +
  geom_point() + theme_bw() + scale_y_log10() +
  labs(title="B-values Left", x=NULL, y="B") +
  scale_color_discrete(type=c("plum3", "seagreen3"), name=NULL) +
  theme(axis.title=element_text(size=16),
        axis.text=element_text(size=12),
        axis.text.x=element_text(angle=90, size=12, vjust=0.5, hjust=1.0),
        legend.position="none")

pq <- ggplot(data=xq, aes(x=rec, y=B, color=relevant)) +
  geom_point() + theme_bw() + scale_y_log10() +
  labs(title="B-values 1/4 chr", x=NULL, y=NULL) +
  scale_color_discrete(type=c("plum3", "seagreen3"), name=NULL) +
  theme(axis.title=element_text(size=16),
        axis.text=element_text(size=12),
        axis.text.x=element_text(angle=90, size=12, vjust=0.5, hjust=1.0),
        legend.position="none")

pm <- ggplot(data=xm, aes(x=rec, y=B, color=relevant)) +
  geom_point() + theme_bw() + scale_y_log10() +
  labs(title="B-values 1/2 chr", x=NULL, y=NULL) +
  scale_color_discrete(type=c("plum3", "seagreen3"), name=NULL) +
  theme(axis.title=element_text(size=16),
        axis.text=element_text(size=12),
        axis.text.x=element_text(angle=90, size=12, vjust=0.5, hjust=1.0),
        legend.position="none")

ql <- ggplot(data=xl, aes(x=rec, y=CummBval, color=relevant)) + geom_point() +
  theme_bw() + scale_y_log10(limits=c(min(xl$CummBval), 1)) +
  labs(title="Cum. B-value, Left", x="Cummulative Rho", y="B") +
  scale_color_discrete(type=c("plum3", "seagreen3"), name=NULL,
                       labels=c(expression(rho < 400),
                                paste(expression(r/s), " < 50"))) +
  theme(axis.title=element_text(size=16),
        axis.text=element_text(size=12),
        axis.text.x=element_text(angle=90, size=12, vjust=0.5, hjust=1.0),
        legend.position="bottom")

qq <- ggplot(data=xq, aes(x=rec, y=CummBval, color=relevant)) + 
  geom_point() + theme_bw() + scale_y_log10() +
  labs(title="Cum. B-value, 1/4 chr", x="Cummulative Rho", y="B") +
  scale_color_discrete(type=c("plum3", "seagreen3"), name=NULL,
                       labels=c(expression(rho < 400),
                                paste(expression(r/s), " < 50"))) +
  theme(axis.title=element_text(size=16),
        axis.text=element_text(size=12),
        axis.text.x=element_text(angle=90, size=12, vjust=0.5, hjust=1.0),
        legend.position="bottom")

qm <- ggplot(data=xm, aes(x=rec, y=CummBval, color=relevant)) +
  geom_point() + theme_bw() + scale_y_log10() +
  labs(title="Cum. B-value, 1/2 chr", x="Cummulative Rho", y="B") +
  scale_color_discrete(type=c("plum3", "seagreen3"), name=NULL,
                       labels=c(expression(rho < 400),
                                paste(expression(r/s), " < 50"))) +
  theme(axis.title=element_text(size=16),
        axis.text=element_text(size=12),
        axis.text.x=element_text(angle=90, size=12, vjust=0.5, hjust=1.0),
        legend.position="bottom")

cp <- plot_grid(pl, pq, pm, ql, qq, qm, align='v', nrow=2)
save_plot("Bvals.png", cp, base_height=10, base_width=15)

cat("bgs_pi.R is done!\n\n")